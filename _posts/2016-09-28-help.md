---
layout: post
title: "写在算法即将部署生产环境之前（求助）"
date: 2016-09-28
comments: true
StatsCS: true

---

这周在对算法进行非常extensive的全方位测试（准确性，效率），包括在R里面的profiling和C里面的profiling。个人认为已经非常好了，但还是不完美。原因如下：

- 因为求似然的公式里面带着log(f)和log(1 - f)这样的东西，所以F矩阵里的元素不能为0和1，所以总在进行替代，把0换成1e-5，把1换成0.99999。

- 因为在做有约束的二次规划，所以拟牛顿加速的越界问题用了back-tracking来解决，求解之后的矩阵小于0和大于1的部分再次以上述方式进行替代。但这个所谓的F矩阵非常非常大，有12万维，如此替代下来，就产生了如下麻烦。

1. 迭代的中间步当然还是很稳的，但到了即将收敛的时候，数值上非常不稳定，似然值不能稳步变大，而是每一步的跳跃几乎相同，所以无法达到两次似然值之差小于1e-4这样的条件。试问这样我是不是可以改一下迭代收敛条件？
2. 拟牛顿的back-tracking部分可以让似然值稳步增大，但是到了即将收敛的时候，由于改变了矩阵里太多的数字，导致某一步直接增加好几百（impossible）。

所以如何让算法完美收敛呢？有没有什么方法能满足我这个还算比较追求完美的人？

如果无法解决这个bug，我可不可以带着这个bug release到GitHub上呢？然后我开个小号，提个issue，让GitHub上面的大神帮帮我？（只有我能想出来这样奇怪的方式了）